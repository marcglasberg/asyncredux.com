> <i>On <a href="https://pub.dev/packages/async_redux" target="_blank">pub.dev</a> since Aug 2019.<br></br>Also available for React as [Kiss State](https://kissforreact.org/).</i>

<br></br>

# Store and state

The **store** holds all the application **state**.

```dart
// The application state
class AppState {
  final String name;
  final int age;
  AppState(this.name, this.age);
}

// Create the store with the initial state
var store = Store<AppState>(
  initialState: AppState('Mary', 25)
);
```

&nbsp;

To use the store, add it in a `StoreProvider` at the top of your widget tree.

```dart
Widget build(context) {
  return StoreProvider<AppState>(
    store: store,
    child: MaterialApp( ... ),
    );
}
```

&nbsp;

# Widgets use the state

Using `context.state`, your widgets rebuild when the state changes.

```dart
class MyWidget extends StatelessWidget {

  Widget build(context)
   => Text('${context.state.name} is ${context.state.age} years old');
}
```

&nbsp;

Or use `context.select()` to get only the parts of the state you need.

```dart
Widget build(context) {

  var state = context.select((st) => (
     name: st.user.name,
     age: st.user.age),
  );

  return Text('${state.name} is ${state.age} years old');
}
```

This also works:

```dart
Widget build(context) {
  var name = context.select((st) => st.name);
  var age = context.select((st) => st.age);

  return Text('$name is $age years old');
}
```

&nbsp;

# Actions change the state

The application state is **immutable**,
so the only way to change it is by **dispatching** an **action**.

```dart
// Dispatch an action
dispatch(Increment());

// Dispatch multiple actions
dispatchAll([Increment(), LoadText()]);

// Dispatch an action and wait for it to finish
await dispatchAndWait(Increment());

// Dispatch multiple actions and wait for them to finish
await dispatchAndWaitAll([Increment(), LoadText()]);
```

&nbsp;

An **action** is a class with a name that describes what it does,
like `Increment`, `LoadText`, or `BuyStock`.

It must include a method called `reduce`.
This "reducer" has access to the current state, and must return a new one to replace it.

```dart
class Increment extends AppAction {

  // The reducer has access to the current state
  AppState reduce()
    => AppState(state.name, state.age + 1); // Returns new state
}
```

&nbsp;

# Widgets can dispatch actions

In your widgets, use `dispatch` to dispatch actions.

```dart
class MyWidget extends StatelessWidget {

  Widget build(context) {
    return ElevatedButton(
      onPressed: () => dispatch(Increment());
    }
}
```

&nbsp;

# Actions can do asynchronous work

Actions may download information from the internet, or do any other async work.

```dart
class LoadText extends AppAction {

  // This reducer returns a Future
  Future<AppState> reduce() async {

    // Download something from the internet
    var response = await http.get('https://dummyjson.com/todos/1');
    var newName = state.response.body;

    // Change the state with the downloaded information
    return AppState(newName, state.age);
  }
}
```

&nbsp;

# Actions can throw errors

If something bad happens, you can simply **throw an error**. In this case, the state will not
change. Errors are caught globally and can be handled in a central place, later.

In special, if you throw a `UserException`, which is a type provided by Async Redux,
a dialog (or other UI) will open automatically, showing the error message to the user.

```dart
class LoadText extends AppAction {

  Future<String> reduce() async {
    var response = await http.get('https://dummyjson.com/todos/1');

    if (response.statusCode == 200) return response.body;
    else throw UserException('Failed to load');
  }
}
```

&nbsp;

To show a spinner while an asynchronous action is running, use `isWaiting(action)`.

To show an error message inside the widget, use `isFailed(action)`.

```dart
class MyWidget extends StatelessWidget {

  Widget build(context) {

    if (context.isWaiting(LoadText)) return CircularProgressIndicator();
    if (context.isFailed(LoadText)) return Text('Loading failed...');
    return Text(context.state);
  }
}
```

&nbsp;

# Actions can dispatch other actions

You can use `dispatchAndWait` to dispatch an action and wait for it to finish.

```dart
class LoadTextAndIncrement extends AppAction {

  Future<AppState> reduce() async {

    // Dispatch and wait for the action to finish
    await dispatchAndWait(LoadText());

    // Only then, increment the state
    return state.copy(count: state.count + 1);
  }
}
```

&nbsp;

You can also dispatch actions in **parallel** and wait for them to finish:

```dart
class BuyAndSell extends AppAction {

  Future<AppState> reduce() async {

    // Dispatch and wait for both actions to finish
    await dispatchAndWaitAll([
      BuyAction('IBM'),
      SellAction('TSLA')
    ]);

    return state.copy(message: 'New cash balance is ${state.cash}');
  }
}
```

&nbsp;

You can also use `waitCondition` to wait until the `state` changes in a certain way:

```dart
class SellStockForPrice extends AppAction {
  final String stock;
  final double limitPrice;
  SellStockForPrice(this.stock, this.limitPrice);

  Future<AppState?> reduce() async {

    // Wait until the stock price is higher than the limit price
    await waitCondition(
      (state) => state.stocks[stock].price >= limitPrice
    );

    // Only then, post the sell order to the backend
    var amount = await postSellOrder(stock);

    return state.copy(
      stocks: state.stocks.setAmount(stock, amount),
    );
}
```

&nbsp;

# Add mixins to your actions

You can use **mixins** to accomplish common tasks.

## Check for Internet connectivity

Mixin `CheckInternet` ensures actions only run with internet,
otherwise an **error dialog** prompts users to check their connection:

```dart
class LoadText extends AppAction with CheckInternet {

   Future<String> reduce() async {
      var response = await http.get('https://dummyjson.com/todos/1');
      ...
   }
}
```

&nbsp;

Mixin `NoDialog` can be added to `CheckInternet` so that no dialog is opened.
Instead, you can display some information in your widgets:

```dart
class LoadText extends AppAction with CheckInternet, NoDialog {
  ...
  }

class MyWidget extends StatelessWidget {
  Widget build(context) {
     if (context.isFailed(LoadText)) Text('No Internet connection');
  }
}
```

&nbsp;

Mixin `AbortWhenNoInternet` aborts the action silently (without showing any dialogs) if there is no
internet connection.

&nbsp;

## NonReentrant

Mixin `NonReentrant` prevents an action from being dispatched while it's already running.

```dart
class LoadText extends AppAction with NonReentrant {
   ...
   }
```

&nbsp;

## Retry

Mixin `Retry` retries the action a few times with exponential backoff,
if it fails. Add `UnlimitedRetries` to retry indefinitely:

```dart
class LoadText extends AppAction with Retry, UnlimitedRetries {
   ...
   }
```

&nbsp;

## Fresh

Mixin `Fresh` marks the data loaded by your action as _fresh_ for a certain period of time.
The same action dispatched again will not run unless the fresh period has ended and the data is considered _stale_.

```dart
class LoadUserCart extends AppAction with Fresh {

  final String userId;
  LoadUserCart(this.userId);

  // Each different `userId` in action LoadUserCart has its own fresh period.
  Object? freshKeyParams() => userId;

  Future<AppState> reduce() async {
    var result = await loadJson('https://example.com/cart/$userId');
    return state.copy(prices: result);
  }
}
```

&nbsp;

## Throttle

Mixin `Throttle` limits how often an action can run, acting as a simple rate limit.
The first dispatch runs right away.
Any later dispatches during the throttle period are ignored.
Once the period ends, the next dispatch is allowed to run again.

```dart
class RefreshFeed extends Action with Throttle {
  final int throttle = 3000; // Milliseconds

  Future<AppState> reduce() async {
    final items = await loadJson('https://example.com/feed');
    return state.copy(feedItems: items);
  }
}
```

&nbsp;

## Debounce

Mixin `Debounce` limits how often an action occurs in response to rapid inputs.
For example, when a user types in a search bar, debouncing ensures that not every keystroke
triggers a server request. Instead, it waits until the user pauses typing before acting.

```dart
class SearchText extends AppAction with Debounce {
  final String searchTerm;
  SearchText(this.searchTerm);

  final int debounce = 350; // Milliseconds

  Future<AppState> reduce() async {

    var response = await http.get(
      Uri.parse('https://example.com/?q=' + encoded(searchTerm))
    );

    return state.copy(searchResult: response.body);
  }
}
```

&nbsp;

## OptimisticCommand

Mixin `OptimisticCommand` helps you provide instant feedback on **blocking** actions that
save information to the server. You immediately apply state changes as if they were
already successful. The UI prevents the user from making other changes until the server confirms the update.
If the update fails, the change is rolled back.

&nbsp;

## OptimisticSync

Mixin `OptimisticSync` helps you provide instant feedback on **non-blocking** actions
that save information to the server. The UI does not prevent the user from making other changes.
Changes are applied locally right away, while the mixin synchronizes those changes with
the server in the background.

&nbsp;

## OptimisticSyncWithPush

Mixin `OptimisticSyncWithPush` is similar to `OptimisticSync`,
but it also assumes that the app listens to the server, for example via WebSockets.
It supports server versioning and multiple clients updating the same data concurrently.

&nbsp;

# Events

You can use `Evt()` to create events that perform **one-time operations**,
to work with widgets like *TextField* or *ListView* that manage their
own internal state.

```dart
// Action that changes the text of a TextField
class ChangeText extends AppAction {
  final String newText;
  ChangeText(this.newText);
  AppState reduce() => state.copy(changeText: Evt(newText));
  }
}

// Action that scrolls a ListView to the top
class ScrollToTop extends AppAction {
  AppState reduce() => state.copy(scroll: Evt(0));
  }
}
```

Then, consume the events in your widgets:

```dart
Widget build(context) {

  var clearText = context.event((st) => st.clearTextEvt);
  if (clearText) controller.clear();

  var newText = context.event((st) => st.changeTextEvt);
  if (newText != null) controller.text = newText;

  return ...
}
```

&nbsp;

# Persist the state

You can add a `persistor` to save the state to the local device disk.

```dart
var store = Store<AppState>(
  persistor: MyPersistor(),
);
```

&nbsp;

# Testing your app is easy

Just dispatch actions and wait for them to finish.
Then, verify the new state or check if some error was thrown.

```dart
class AppState {
  List<String> items;
  int selectedItem;
}

test('Selecting an item', () async {

    var store = Store<AppState>(
      initialState: AppState(
        items: ['A', 'B', 'C']
        selectedItem: -1, // No item selected
      ));

    // Should select item 2
    await store.dispatchAndWait(SelectItem(2));
    expect(store.state.selectedItem, 'B');

    // Fail to select item 42
    var status = await store.dispatchAndWait(SelectItem(42));
    expect(status.originalError, isA<>(UserException));
});
```

&nbsp;

# Advanced setup

If you are the Team Lead, you set up the app's infrastructure in a central place,
and allow your developers to concentrate solely on the business logic.

You can add a `stateObserver` to collect app metrics, an `errorObserver` to log errors,
an `actionObserver` to print information to the console during development,
and a `globalWrapError` to catch all errors.

```dart
var store = Store<String>(
  stateObserver: [MyStateObserver()],
  errorObserver: [MyErrorObserver()],
  actionObservers: [MyActionObserver()],
  globalWrapError: MyGlobalWrapError(),
```

&nbsp;

For example, the following `globalWrapError` handles `PlatformException` errors thrown
by Firebase. It converts them into `UserException` errors, which are built-in types that
automatically show a message to the user in an error dialog:

```dart
Object? wrap(error, stackTrace, action) =>
  (error is PlatformException)
    ? UserException('Error connecting to Firebase')
    : error;
}
```

&nbsp;

# Advanced action configuration

The Team Lead may create a base action class that all actions will extend, and add some common
functionality to it. For example, getter shortcuts to important parts of the state,
and selectors to help find information.

```dart
class AppState {
  List<Item> items;
  int selectedItem;
}

class Action extends ReduxAction<AppState> {

  // Getter shortcuts
  List<Item> get items => state.items;
  Item get selectedItem => state.selectedItem;

  // Selectors
  Item? findById(int id) => items.firstWhereOrNull((item) => item.id == id);
  Item? searchByText(String text) => items.firstWhereOrNull((item) => item.text.contains(text));
  int get selectedIndex => items.indexOf(selectedItem);
}
```

&nbsp;

Now, all actions can use them to access the state in their reducers:

```dart
class SelectItem extends AppAction {
  final int id;
  SelectItem(this.id);

  AppState reduce() {
    Item? item = findById(id);
    if (item == null) throw UserException('Item not found');
    return state.copy(selected: item);
  }
}
```

&nbsp;

# Claude Code Skills

This package includes **Skills** that help you use `async_redux` with
Claude Code and other AI agents.

To use it, you have to copy the skills
from [this repository](https://github.com/marcglasberg/async_redux/tree/master/.claude/skills)
to your project.
[Learn more](https://asyncredux.com/flutter/claude-code-skills).
